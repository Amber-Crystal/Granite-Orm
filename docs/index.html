<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta id="repository-name" content="github.com/Amber-Crystal/granite-orm">
  <link href="css/style.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="js/doc.js"></script>
  <title>README - github.com/Amber-Crystal/granite-orm</title>
</head>
<body>

<div id="types-list">
  <div id="search-box">
    <input type="search" id="search-input" placeholder="Search...">
  </div>

  <ul>
    <li class="current"><a href="index.html">README</a></li>
  </ul>

  <ul>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite" data-name="granite">
      <a href="Granite.html">Granite</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/AssociationCollection" data-name="granite::associationcollection(owner, target)">
      <a href="Granite/AssociationCollection.html">AssociationCollection</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Associations" data-name="granite::associations">
      <a href="Granite/Associations.html">Associations</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Base" data-name="granite::base">
      <a href="Granite/Base.html">Base</a>
      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Callbacks" data-name="granite::callbacks">
      <a href="Granite/Callbacks.html">Callbacks</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Callbacks/Abort" data-name="granite::callbacks::abort">
      <a href="Granite/Callbacks/Abort.html">Abort</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Collection" data-name="granite::collection(m)">
      <a href="Granite/Collection.html">Collection</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Error" data-name="granite::error">
      <a href="Granite/Error.html">Error</a>
      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Fields" data-name="granite::fields">
      <a href="Granite/Fields.html">Fields</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Fields/Type" data-name="granite::fields::type">
      <a href="Granite/Fields/Type.html">Type</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Migrator" data-name="granite::migrator">
      <a href="Granite/Migrator.html">Migrator</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Migrator/Base" data-name="granite::migrator::base">
      <a href="Granite/Migrator/Base.html">Base</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query" data-name="granite::query">
      <a href="Granite/Query.html">Query</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Assembler" data-name="granite::query::assembler">
      <a href="Granite/Query/Assembler.html">Assembler</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Assembler/Base" data-name="granite::query::assembler::base(model)">
      <a href="Granite/Query/Assembler/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Assembler/Postgresql" data-name="granite::query::assembler::postgresql(model)">
      <a href="Granite/Query/Assembler/Postgresql.html">Postgresql</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Builder" data-name="granite::query::builder(model)">
      <a href="Granite/Query/Builder.html">Builder</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Builder/FieldData" data-name="granite::query::builder::fielddata">
      <a href="Granite/Query/Builder/FieldData.html">FieldData</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Builder/FieldName" data-name="granite::query::builder::fieldname">
      <a href="Granite/Query/Builder/FieldName.html">FieldName</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Builder/Sort" data-name="granite::query::builder::sort">
      <a href="Granite/Query/Builder/Sort.html">Sort</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/BuilderMethods" data-name="granite::query::buildermethods">
      <a href="Granite/Query/BuilderMethods.html">BuilderMethods</a>
      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Executor" data-name="granite::query::executor">
      <a href="Granite/Query/Executor.html">Executor</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Executor/List" data-name="granite::query::executor::list(model)">
      <a href="Granite/Query/Executor/List.html">List</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Executor/Shared" data-name="granite::query::executor::shared">
      <a href="Granite/Query/Executor/Shared.html">Shared</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Query/Executor/Value" data-name="granite::query::executor::value(model, scalar)">
      <a href="Granite/Query/Executor/Value.html">Value</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Querying" data-name="granite::querying">
      <a href="Granite/Querying.html">Querying</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Querying/NotFound" data-name="granite::querying::notfound">
      <a href="Granite/Querying/NotFound.html">NotFound</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Settings" data-name="granite::settings">
      <a href="Granite/Settings.html">Settings</a>
      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Table" data-name="granite::table">
      <a href="Granite/Table.html">Table</a>
      
    </li>
  
  <li class="parent " data-id="github.com/Amber-Crystal/granite-orm/Granite/Transactions" data-name="granite::transactions">
      <a href="Granite/Transactions.html">Transactions</a>
      
        <ul>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Transactions/ClassMethods" data-name="granite::transactions::classmethods">
      <a href="Granite/Transactions/ClassMethods.html">ClassMethods</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/Amber-Crystal/granite-orm/Granite/Validators" data-name="granite::validators">
      <a href="Granite/Validators.html">Validators</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

</div>

<div id="main-content">
<h1>Granite</h1>

<p><a href="https://github.com/Amber-Crystal/amber" target="_blank">Amber</a> is a web framework written in
the <a href="https://github.com/crystal-lang/crystal" target="_blank">Crystal</a> language.</p>

<p>This project is to provide an ORM in Crystal.</p>

<p><a href="https://travis-ci.org/amberframework/granite" target="_blank"><img src="https://img.shields.io/travis/amberframework/granite.svg?maxAge=360" alt="Build Status"/></a></p>

<h2>Installation</h2>

<p>Add this library to your projects dependencies along with the driver in
your <code>shard.yml</code>.  This can be used with any framework but was originally
designed to work with the amber framework in mind.  This library will work
with kemal or any other framework as well.</p>

<pre><code class='language-yaml'>dependencies:
  granite:
    github: amberframework/granite

  # Pick your database
  mysql:
    github: crystal-lang/crystal-mysql

  sqlite3:
    github: crystal-lang/crystal-sqlite3

  pg:
    github: will/crystal-pg
</code></pre>

<p>Next you will need to create a <code>config/database.yml</code>
You can leverage environment variables using <code>${}</code> syntax.</p>

<pre><code class='language-yaml'>mysql:
  database: "mysql://username:password@hostname:3306/database_${AMBER_ENV}"
pg:
  database: "postgres://username:password@hostname:5432/database"
sqlite:
  database: "sqlite3:./config/${DB_NAME}.db"</code></pre>

<p>Or you can set the <code>DATABASE_URL</code> environment variable.  This will override the config/database.yml</p>

<h2>Usage</h2>

<p>Here is an example using Granite Model</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;granite/adapter/mysql&quot;</span>

<span class="k">class</span> <span class="t">Post</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter mysql
  field name : <span class="t">String</span>
  field body : <span class="t">String</span>
  timestamps
<span class="k">end</span></code></pre>

<p>You can disable the timestamps for SqlLite since TIMESTAMP is not supported for this database:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;granite/adapter/sqlite&quot;</span>

<span class="k">class</span> <span class="t">Comment</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter sqlite
  table_name post_comments
  field name : <span class="t">String</span>
  field body : <span class="t">String</span>
<span class="k">end</span></code></pre>

<h3>id, created_at, updated_at</h3>

<p>The primary key is automatically created for you and if you use <code>timestamps</code> they will be
automatically updated for you.</p>

<p>Here are the MySQL field definitions for id, created_at, updated_at</p>

<pre><code class='language-mysql'>  id BIGINT NOT NULL AUTO_INCREMENT
  # Your fields go here
  created_at TIMESTAMP
  updated_at TIMESTAMP
  PRIMARY KEY (id)</code></pre>

<h3>Custom Primary Key</h3>

<p>For legacy database mappings, you may already have a table and the primary key is not named <code>id</code> or <code>Int64</code>.</p>

<p>We have a macro called <code>primary</code> to help you out:</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Site</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter mysql
  primary custom_id : <span class="t">Int32</span>
  field name : <span class="t">String</span>
<span class="k">end</span></code></pre>

<p>This will override the default primary key of <code>id : Int64</code>.</p>

<h4>Natural Keys</h4>

<p>For natural keys, you can set <code>auto: false</code> option to disable auto increment insert.</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Site</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter mysql
  primary code : <span class="t">String</span>, auto: <span class="n">false</span>
  field name : <span class="t">String</span>
<span class="k">end</span></code></pre>

<h4>UUIDs</h4>

<p>For databases that utilize UUIDs as the primary key, the <code>primary</code> macro can be used again with the <code>auto: false</code> option.  A <code>before_create</code> callback can be added to the model to randomly generate and set a secure UUID on the record before it is saved to the database.</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Book</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  <span class="k">require</span> <span class="s">&quot;uuid&quot;</span>
  adapter mysql
  primary <span class="t">ISBN</span> : <span class="t">String</span>, auto: <span class="n">false</span>
  field name : <span class="t">String</span>

  before_create <span class="n">:assign_isbn</span>

  <span class="k">def</span> <span class="m">assign_isbn</span>
    @ISBN <span class="o">=</span> <span class="t">UUID</span>.random.to_s
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<h3>Bulk Insertions</h3>

<h4>Import</h4>

<p><strong>Note:  Imports do not trigger callbacks automatically.  See <a href="#running-callbacks" target="_blank">Running Callbacks</a>.</strong></p>

<p>Each model has an <code>import</code> class level method to import an array of models in one bulk insert statement.</p>

<pre><code class='language-Crystal'>models = [
  Model.new(id: 1, name: "Fred", age: 14),
  Model.new(id: 2, name: "Joe", age: 25),
  Model.new(id: 3, name: "John", age: 30),
]

Model.import(models)</code></pre>

<h4>update_on_duplicate</h4>

<p>The <code>import</code> method has an optional <code>update_on_duplicate</code>  + <code>columns</code> params that allows you to specify the columns (as an array of strings) that should be updated if primary constraint is violated.</p>

<pre><code class='language-Crystal'>models = [
  Model.new(id: 1, name: "Fred", age: 14),
  Model.new(id: 2, name: "Joe", age: 25),
  Model.new(id: 3, name: "John", age: 30),
]

Model.import(models)

Model.find!(1).name # => Fred

models = [
  Model.new(id: 1, name: "George", age: 14),
]

Model.import(models, update_on_duplicate: true, columns: %w(name))

Model.find!(1).name # => George</code></pre>

<p><strong>NOTE:  If using PostgreSQL you must have version 9.5+ to have the on_duplicate_key_update feature.</strong></p>

<h4>ignore_on_duplicate</h4>

<p>The <code>import</code> method has an optional <code>ignore_on_duplicate</code> param, that takes a boolean, which will skip records if the primary constraint is violated.</p>

<pre><code class='language-Crystal'>models = [
  Model.new(id: 1, name: "Fred", age: 14),
  Model.new(id: 2, name: "Joe", age: 25),
  Model.new(id: 3, name: "John", age: 30),
]

Model.import(models)

Model.find!(1).name # => Fred

models = [
  Model.new(id: 1, name: "George", age: 14),
]

Model.import(models, ignore_on_duplicate: true)

Model.find!(1).name # => Fred</code></pre>

<h4>batch_size</h4>

<p>The <code>import</code> method has an optional <code>batch_size</code> param, that takes an integer.  The batch_size determines the number of models to import in each INSERT statement.  This defaults to the size of the models array, i.e. only 1 INSERT statement.</p>

<pre><code class='language-Crystal'>models = [
  Model.new(id: 1, name: "Fred", age: 14),
  Model.new(id: 2, name: "Joe", age: 25),
  Model.new(id: 3, name: "John", age: 30),
  Model.new(id: 3, name: "Bill", age: 66),
]

Model.import(models, batch_size: 2)
# => First SQL INSERT statement imports Fred and Joe
# => Second SQL INSERT statement imports John and Bill</code></pre>

<h4>Running Callbacks</h4>

<p>Since the <code>import</code> method runs on the class level, callbacks are not triggered automatically, they have to be triggered manually.  For example, using the Item class with a UUID primary key:</p>

<pre><code class='language-Crystal'>require "uuid"

class Item &lt; Granite::Base
  adapter mysql
  table_name items

  primary item_id : String, auto: false
  field item_name : String

  before_create :generate_uuid

  def generate_uuid
    @item_id = UUID.random.to_s
  end
end  </code></pre>

<pre><code class='language-Crystal'>items = [
  Item.new(item_name: "item1"),
  Item.new(item_name: "item2"),
  Item.new(item_name: "item3"),
  Item.new(item_name: "item4"),
]

# If we did `Item.import(items)` now, it would fail since the item_id wouldn't get set before saving the record, violating the primary key constraint.

# Manually run the callback on each model to generate the item_id.
items.each(&.before_create)

# Each model in the array now has a item_id set, so can be imported.
Item.import(items)

# This can also be used for a single record.
item = Item.new(item_name: "item5")
item.before_create
item.save</code></pre>

<p><strong>Note:  Manually running your callbacks is mainly aimed at bulk imports.  Running them before a normal <code>.save</code>, for example, would run your callbacks twice.</strong></p>

<h3>SQL</h3>

<p>To clear all the rows in the database:</p>

<pre><code class='language-crystal'><span class="t">Post</span>.clear <span class="c">#truncate the table</span></code></pre>

<h4>Find All</h4>

<pre><code class='language-crystal'>posts <span class="o">=</span> <span class="t">Post</span>.all
<span class="k">if</span> posts
  posts.each <span class="k">do</span> <span class="o">|</span>post<span class="o">|</span>
    puts post.name
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<h4>Find First</h4>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.first
<span class="k">if</span> post
  puts post.name
<span class="k">end</span>

post <span class="o">=</span> <span class="t">Post</span>.first! <span class="c"># raises when no records exist</span></code></pre>

<h4>Find</h4>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.find <span class="n">1</span>
<span class="k">if</span> post
  puts post.name
<span class="k">end</span>

post <span class="o">=</span> <span class="t">Post</span>.find! <span class="n">1</span> <span class="c"># raises when no records found</span></code></pre>

<h4>Find By</h4>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.find_by <span class="n">:slug</span>, <span class="s">&quot;example_slug&quot;</span>
<span class="k">if</span> post
  puts post.name
<span class="k">end</span>

post <span class="o">=</span> <span class="t">Post</span>.find_by! <span class="n">:slug</span>, <span class="s">&quot;foo&quot;</span> <span class="c"># raises when no records found</span></code></pre>

<h4>Insert</h4>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.<span class="k">new</span>
post.name <span class="o">=</span> <span class="s">&quot;Granite Rocks!&quot;</span>
post.body <span class="o">=</span> <span class="s">&quot;Check this out.&quot;</span>
post.save</code></pre>

<h4>Update</h4>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.find <span class="n">1</span>
post.name <span class="o">=</span> <span class="s">&quot;Granite Really Rocks!&quot;</span>
post.save</code></pre>

<h4>Delete</h4>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.find <span class="n">1</span>
post.destroy
puts <span class="s">&quot;deleted&quot;</span> <span class="k">unless</span> post</code></pre>

<h3>Queries</h3>

<p>The where clause will give you full control over your query.</p>

<h4>All</h4>

<p>When using the <code>all</code> method, the SQL selected fields will always match the
fields specified in the model.</p>

<p>Always pass in parameters to avoid SQL Injection.  Use a <code>?</code>
in your query as placeholder. Checkout the <a href="https://github.com/crystal-lang/crystal-db" target="_blank">Crystal DB Driver</a>
for documentation of the drivers.</p>

<p>Here are some examples:</p>

<pre><code class='language-crystal'>posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;WHERE name LIKE ?&quot;</span>, [<span class="s">&quot;Joe%&quot;</span>])
<span class="k">if</span> posts
  posts.each <span class="k">do</span> <span class="o">|</span>post<span class="o">|</span>
    puts post.name
  <span class="k">end</span>
<span class="k">end</span>

<span class="c"># ORDER BY Example</span>
posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;ORDER BY created_at DESC&quot;</span>)

<span class="c"># JOIN Example</span>
posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;JOIN comments c ON c.post_id = post.id
                  WHERE c.name = ?
                  ORDER BY post.created_at DESC&quot;</span>,
                  [<span class="s">&quot;Joe&quot;</span>])
</code></pre>

<h4>First</h4>

<p>It is common to only want the first result and append a <code>LIMIT 1</code> to the query.
This is what the <code>first</code> method does.</p>

<p>For example:</p>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.first(<span class="s">&quot;ORDER BY posts.name DESC&quot;</span>)</code></pre>

<p>This is the same as:</p>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;ORDER BY posts.name DESC LIMIT 1&quot;</span>).first</code></pre>

<h3>Relationships</h3>

<h4>One to Many</h4>

<p><code>belongs_to</code> and <code>has_many</code> macros provide a rails like mapping between Objects.</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">User</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter mysql

  has_many <span class="n">:posts</span>

  field email : <span class="t">String</span>
  field name : <span class="t">String</span>
  timestamps
<span class="k">end</span></code></pre>

<p>This will add a <code>posts</code> instance method to the user which returns an array of posts.</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Post</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter mysql

  belongs_to <span class="n">:user</span>

  field title : <span class="t">String</span>
  timestamps
<span class="k">end</span></code></pre>

<p>This will add a <code>user</code> and <code>user=</code> instance method to the post.</p>

<p>For example:</p>

<pre><code class='language-crystal'>user <span class="o">=</span> <span class="t">User</span>.find <span class="n">1</span>
user.posts.each <span class="k">do</span> <span class="o">|</span>post<span class="o">|</span>
  puts post.title
<span class="k">end</span>

post <span class="o">=</span> <span class="t">Post</span>.find <span class="n">1</span>
puts post.user

post.user <span class="o">=</span> user
post.save</code></pre>

<p>In this example, you will need to add a <code>user_id</code> and index to your posts table:</p>

<pre><code class='language-mysql'>CREATE TABLE posts (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT,
  title VARCHAR,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

CREATE INDEX 'user_id_idx' ON posts (user_id);</code></pre>

<h4>Many to Many</h4>

<p>Instead of using a hidden many-to-many table, Granite recommends always creating a model for your join tables.  For example, let's say you have many <code>users</code> that belong to many <code>rooms</code>. We recommend adding a new model called <code>participants</code> to represent the many-to-many relationship.</p>

<p>Then you can use the <code>belongs_to</code> and <code>has_many</code> relationships going both ways.</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">User</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  has_many <span class="n">:participants</span>

  field name : <span class="t">String</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Participant</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  belongs_to <span class="n">:user</span>
  belongs_to <span class="n">:room</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Room</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  has_many <span class="n">:participants</span>

  field name : <span class="t">String</span>
<span class="k">end</span></code></pre>

<p>The Participant class represents the many-to-many relationship between the Users and Rooms.</p>

<p>Here is what the database table would look like:</p>

<pre><code class='language-mysql'>CREATE TABLE participants (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT,
  room_id BIGINT,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

CREATE INDEX 'user_id_idx' ON TABLE participants (user_id);
CREATE INDEX 'room_id_idx' ON TABLE participants (room_id);</code></pre>

<h5>has_many through:</h5>

<p>As a convenience, we provide a <code>through:</code> clause to simplify accessing the many-to-many relationship:</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">User</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  has_many <span class="n">:participants</span>
  has_many <span class="n">:rooms</span>, through: participants

  field name : <span class="t">String</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Participant</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  belongs_to <span class="n">:user</span>
  belongs_to <span class="n">:room</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Room</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  has_many <span class="n">:participants</span>
  has_many <span class="n">:users</span>, through: participants

  field name : <span class="t">String</span>
<span class="k">end</span></code></pre>

<p>This will allow you to find all the rooms that a user is in:</p>

<pre><code class='language-crystal'>user <span class="o">=</span> <span class="t">User</span>.first
user.rooms.each <span class="k">do</span> <span class="o">|</span>room<span class="o">|</span>
  puts room.name
<span class="k">end</span></code></pre>

<p>And the reverse, all the users in a room:</p>

<pre><code class='language-crystal'>room <span class="o">=</span> <span class="t">Room</span>.first
room.users.each <span class="k">do</span> <span class="o">|</span>user<span class="o">|</span>
  puts user.name
<span class="k">end</span></code></pre>

<h3>Errors</h3>

<p>All database errors are added to the <code>errors</code> array used by Granite::Validators with the symbol ':base'</p>

<pre><code class='language-crystal'>post <span class="o">=</span> <span class="t">Post</span>.<span class="k">new</span>
post.save
post.errors[<span class="n">0</span>].to_s.should eq <span class="s">&quot;ERROR: name cannot be null&quot;</span></code></pre>

<h3>Callbacks</h3>

<p>There is support for callbacks on certain events.</p>

<p>Here is an example:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;granite/adapter/pg&quot;</span>

<span class="k">class</span> <span class="t">Post</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter pg

  before_save <span class="n">:upcase_title</span>

  field title : <span class="t">String</span>
  field content : <span class="t">String</span>
  timestamps

  <span class="k">def</span> <span class="m">upcase_title</span>
    <span class="k">if</span> title <span class="o">=</span> @title
      @title <span class="o">=</span> title.upcase
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>You can register callbacks for the following events:</p>

<h4>Create</h4>

<ul><li>before_save</li><li>before_create</li><li><strong>save</strong></li><li>after_create</li><li>after_save</li></ul>

<h4>Update</h4>

<ul><li>before_save</li><li>before_update</li><li><strong>save</strong></li><li>after_update</li><li>after_save</li></ul>

<h4>Destroy</h4>

<ul><li>before_destroy</li><li><strong>destroy</strong></li><li>after_destroy</li></ul>

<h3>Migration</h3>

<ul><li><code>migrator</code> provides <code>drop</code>, <code>create</code> and <code>drop_and_create</code> methods</li></ul>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">User</span> <span class="o"><</span> <span class="t">Granite</span><span class="t">::</span><span class="t">Base</span>
  adapter mysql
  field name : <span class="t">String</span>
<span class="k">end</span>

<span class="t">User</span>.migrator.drop_and_create
<span class="c"># =&gt; &quot;DROP TABLE IF EXISTS `users`;&quot;</span>
<span class="c"># =&gt; &quot;CREATE TABLE `users` (id BIGSERIAL PRIMARY KEY, name VARCHAR(255));&quot;</span>

<span class="t">User</span>.migrator(table_options: <span class="s">&quot;ENGINE=InnoDB DEFAULT CHARSET=utf8&quot;</span>).create
<span class="c"># =&gt; &quot;CREATE TABLE ... ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;</span></code></pre>

<h2>Contributing</h2>

<ol><li>Fork it ( https://github.com/amberframework/granite/fork )</li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<h2>Running tests</h2>

<p>Granite uses Crystal's built in test framework. The tests can be run with <code>$ crystal spec</code>.</p>

<p>The test suite depends on access to a PostgreSQL, MySQL, and SQLite database to ensure the adapters work as intended.</p>

<h3>Docker setup</h3>

<p>There is a self-contained testing environment provided via the <code>docker-compose.yml</code> file in this repository.</p>

<p>After you have docker installed do the following to run tests:</p>

<h4>First run</h4>

<pre><code></code></pre>

<h4>Subsequent runs</h4>

<pre><code></code></pre>

<h4>Cleanup</h4>

<p>If you're done testing and you'd like to shut down and clean up the docker dependences run the following:</p>

<pre><code></code></pre>

<h3>Local setup</h3>

<p>If you'd like to test without docker you can do so by following the instructions below:</p>

<ol><li>Install dependencies with <code>$ crystal deps</code></li><li>Update .env to use appropriate ENV variables, or create appropriate databases.</li><li>Setup databases:</li></ol>

<h4>PostgreSQL</h4>

<pre><code class='language-sql'>CREATE USER granite WITH PASSWORD 'password';

CREATE DATABASE granite_db;

GRANT ALL PRIVILEGES ON DATABASE granite_db TO granite;</code></pre>

<h4>MySQL</h4>

<pre><code class='language-sql'>CREATE USER 'granite'@'localhost' IDENTIFIED BY 'password';

CREATE DATABASE granite_db;

GRANT ALL PRIVILEGES ON granite_db.* TO 'granite'@'localhost' WITH GRANT OPTION;</code></pre>

<ol><li>Export <code>.env</code> with <code>$ source .env</code></li><li><code>$ crystal spec</code></li></ol>
</div>
</body>
</html>
